# 变量

## var 声明

### var 声明的作用域

使用 var 声明的变量将会变成该函数内部的局部变量，比如下面声明的变量将在函数退出时被销毁：

```javascript
function test() {
  var message = "hi";
}
test();
console.log(message); //出错！;
```

假如不用 var 关键字声明，该变量将会变成全局变量

```javascript
function test() {
  message = "hi";
}
test();
console.log(message); // “hi”;
```

### var 声明提升

下面这段代码不会报错。

```javascript
function foo() {
  console.log(message); // undefined
  var message = "hi";
}
foo();
```

之所以不报错是因为可以把它理解为如下代码

```javascript
function foo() {
  var message;
  console.log(message);
  message = "hi";
}
```

这就是提升，用 var 定义的变量都会被提升到函数作用域最顶部。此外，反复声明同一个变量也没有问题

## let 声明

### 作用域不同

用 var 声明的作用域是函数作用域，用 let 声明的作用域是块作用域，比如下面：

```javascript
if (true) {
  var message = "hello";
  let result = "world";
  console.log(message); // 'hello'
  console.log(result); // 'world'
}
console.log(message); // 'hello'
console.log(result); // 报错 result is not defined
```

### 不能重复声明

```javascript
let age = 20;
let age = 30; // 报错 'age' has already been declared
```

### 在不同的块中可以重复声明

```javascript
let age = 20;
if (true) {
  let age = 30;
  console.log(age); // 30
}
console.log(age); // 20
```

### 暂时性死区（不会变量提升）

```javascript
console.log(varAge); // undefined
console.log(age); // 报错
let age = 20;
var varAge = 30;
```

### 不会成为 window 对象属性

```javascript
var varAge = 30;
console.log(window.varAge); // 30
let age = 20;
console.log(window.age); // 20
```

### for 循环中的 let 声明

```javascript
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 0); // 0 1 2 3 4
}
console.log(i); // 报错 not defined
for (var i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 0); // 5 5 5 5 5
}
console.log(i); // 5
```

## const 声明

1. 与 let 用法基本相同，但是定义变量的同时必须初始化，而且不允许修改。

2. const 声明的限制只是它指向的变量的引用，换句话说，const 声明的对象是可以修改的。

3. for 循环涉及到自增时，无法使用 const 声明，但是`for...in`,`for...of`可以。

```javascript
for (const key in { a: 1, b: 2 }) {
  console.log(key); // a b
}

for (const value of [1, 2, 3, 4, 5]) {
  console.log(value); // 1 2 3 4 5
}
```

## 数据类型

### typeof 操作符

返回值：

1. undefined
2. boolean
3. string
4. number
5. object
6. function
7. symbol

typeof 是一个操作符，它可以使用参数也可以不使用参数

```javascript
const message = "myMessage";
console.log(typeof message); // string
console.log(typeof message); //string
console.log(typeof 95); // number
console.log(typeof null); // object
console.log(typeof function () {}); // function
```

### Undefined

神奇操作

```javascript
let message; // message被声明，值为undefined
let age; // 确保没有声明过这个变量

console.log(message); // undefined
console.log(age); // 报错
console.log(typeof message); // undefined
console.log(typeof age); // undefined
```

上面的例子中，虽然 age 没有声明，但是 typeof 检测出来的值还是 undefined

### Null

从逻辑上来说，Null 其实就是一个空对象，所以定义要保存对象的变量时，可以使用 null 来初始化。

### Boolean

要将其他值转换成布尔值可以使用`Boolean()`转换函数

| 数据类型  | 转换为 true 的值 | 转换为 false 的值 |
| :-------: | :--------------: | :---------------: |
|  String   |    非空字符串    |    ""空字符串     |
|  Number   |      非零值      |      0、NAN       |
|  Object   |     任意对象     |       null        |
| Undefined |       没有       |     undefined     |

### Number

```javascript
console.log(0.1 + 0.2); // 0.30000000000000004
```

导致这个发生的原因主要是因为使用了 IEEE 754 数值，在计算机中是无法直接对十进制数字进行运算的，需要转换为二进制数，在转换过程中导致了精度缺失。

### String

字符串是不可变的。一旦创建，它们的值就不能变了，要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，比如

```javascript
let lang = "java";
lang = lang + "Script";
```

这里给 lang 赋值的过程首先会分配一个足够容纳 10 个字符的空间，然后填充上“java”和“script”，最后将它们俩销毁。所以这在早期浏览器中处理是非常慢的，后面的版本中都针对性地解决了这个问题。

`String()`和 `toString()`的不同:

```javascript
let value1 = 11;
let value2 = true;
let value3 = null;
let value4;
console.log(String(value1)); // "11"
console.log(String(value2)); // "true"
console.log(String(value3)); // "null"
console.log(String(value4)); // "undefined"
console.log(value1.toString()); // "11"
console.log(value2.toString()); // "true"
console.log(value3.toString()); // 报错
console.log(value4.toString()); // 报错
```

`toString()`方法无法处理 `null` 和 `undefined` 类型，而 `String()` 可以，当用 `String()` 类型转换字符串时，如果该值能用 `toString()`方法，会去执行它的 `toString()`方法，否则直接将其转换为字符串。

#### 模版字符串

模版字符串``会保留其中的空格和换行

```javascript
let moban1 = `first line
second line`;
let moban2 = `first line
              second line`;
console.log(moban1);
// first line
// second line
console.log(moban2);
// first line
//              second line
```

字符串插值，`${}`, 其原理是所有插入的值都会使用 toString 强制转换为字符串

```javascript
let foo = { toString: () => "pingchangxin" };
console.log(`i am ${foo}`);
```

#### 模版字面量标签函数

接收的第一个参数为被插值分割后的模版，以及各个插值的结果

```javascript
let a = 6;
let b = 9;
const simpleTag = (string, ...expressions) => {
  console.log(string);
  expressions.forEach((item) => console.log(item));
};
let taggedRes = simpleTag`${a}+${b}=${a + b}`;
// [ '', '+', '=', '' ]
// 6
// 9
// 15
```

#### 原始字符串

模版字面量也可以直接获取原始的模版字面量内容（如换行符和 Unicode 字符）

```javascript
console.log(`\u00A9`); // ©
console.log(String.raw`\u00A9`); // \u00A9
console.log(`first line \nsecond line`);
// first line
// second line
console.log(String.raw`first line \nsecond line`); // first line \nsecond line
console.log(["first line \nsecond line"].raw);
```

### Symbol 类型

特点：唯一性。

```javascript
let aaa = Symbol();
let bbb = Symbol();
console.log(aaa === bbb); // false
```

#### 全局符号注册表（共享 Symbol）

`Symbol.for()`创建的变量会在全局运行时注册表，发现不存在的符号就进行添加，否则返回该符号的实例。如果传入的不是字符串则自动转换为字符串。

```javascript
let aaa = Symbol.for("foo");
let bbb = Symbol.for("foo");
let ccc = Symbol.for();
console.log(aaa === bbb); // true
console.log(ccc); // Symbol(undefined)
```

还可以使用`Symbol.keyFor()`来查找符号，返回对应的字符串键

```javascript
let aaa = Symbol.for("foo");
console.log(Symbol.keyFor(aaa)); // foo
```

#### 使用 Symbol 作为对象的属性

1. `getOwnPropertyNames`: 返回对象的常规属性数组
2. `getOwnPropertySymbols`: 返回对象符号属性的数组
3. `getOwnPropertyDescriptors`: 返回常规属性和符号属性的对象
4. `Reflect.ownKeys`: 返回常规属性和符号属性的数组

```javascript
const s1 = Symbol("foo");
const s2 = Symbol("bar");

const o = {
  [s1]: "foo val",
  [s2]: "bar val",
  baz: "baz val",
  foz: "foz val",
};

console.log(Object.getOwnPropertyNames(o)); // ['baz', 'foz']
console.log(Object.getOwnPropertySymbols(o)); // [ Symbol(foo), Symbol(bar) ]
console.log(Object.getOwnPropertyDescriptors(o));
/*
  {
  baz: {
    value: 'baz val',
    writable: true,
    enumerable: true,
    configurable: true
  },
  foz: {
    value: 'foz val',
    writable: true,
    enumerable: true,
    configurable: true
  },
  [Symbol(foo)]: {
    value: 'foo val',
    writable: true,
    enumerable: true,
    configurable: true
  },
  [Symbol(bar)]: {
    value: 'bar val',
    writable: true,
    enumerable: true,
    configurable: true
  }
}
*/
console.log(Reflect.ownKeys(o)); // [ 'baz', 'foz', Symbol(foo), Symbol(bar) ]
```

#### Symbol.hasInstance

ES6 中 `instanceof` 操作符会使用`Symbol.hasInstance`函数来确定关系

```javascript
function Foo() {}
let f = new Foo();
console.log(f instanceof Foo); // true
console.log(Foo[Symbol.hasInstance](f)); // true

class baz {
  static [Symbol.hasInstance]() {
    return false;
  }
}
const b = new baz();
console.log(baz[Symbol.hasInstance](b)); // false
console.log(b instanceof baz); // false
```

#### Symbol.isConcatSpreadable

ES6 中的`cancat()`方法会根据这个值选择如何拼接。
默认情况下，数据对象会被打平到已有数组中，false 或者假值会导致整个对象追加到数组末尾；类数组默认会被追加到数组末尾，true 或真值会导致整个类数组对象打平到已有数组中，其他类型的对象，在被设置为 true 时，将被忽略

```javascript
let init = ["foo"];
let arr = ["bar"];
console.log(init.concat(arr)); // [ 'foo', 'bar' ]
arr[Symbol.isConcatSpreadable] = false;
console.log(init.concat(arr)); // [ 'foo', [ 'bar', [Symbol(Symbol.isConcatSpreadable)]: false ] ]
let arrLikeObj = { length: 1, 0: "baz" };
console.log(init.concat(arrLikeObj)); // [ 'foo', { '0': 'baz', length: 1 } ]
arrLikeObj[Symbol.isConcatSpreadable] = true;
console.log(init.concat(arrLikeObj)); // [ 'foo', 'baz' ]
let otherArr = new Set().add("qux");
console.log(init.concat(otherArr)); // [ 'foo', Set(1) { 'qux' } ]
otherArr[Symbol.isConcatSpreadable] = true;
console.log(init.concat(otherArr)); // [ 'foo' ]
```

#### Symbol.iterator

for-of 循环将会调用这个方法，返回一个 `Generator`，可以通过显式地调用 `next()`方法返回，也可以通过生成器函数自动返回

#### Symbol.match

与字符串方法`match()`有关

```javascript
console.log("foobar".match(/bar/)); // [ 'bar', index: 3, input: 'foobar', groups: undefined ]
class FooMatch {
  constructor(str) {
    this.str = str;
  }
  [Symbol.match](target) {
    return target.includes(this.str);
  }
}
console.log("foobar".match(new FooMatch("foo"))); // true
console.log("barbar".match(new FooMatch("qux"))); // false
```

#### 其他 Symbol 的方法

1. `Symbol.replace`：由`String.prototype.replace()`方法使用
2. `Symbol.search`：由`String.prototype.search()`方法使用
3. `Symbol.species`：函数值属性，其被构造函数用以创建派生对象，用于子类覆盖对象的默认构造函数。
4. `Symbol.split`：由`String.prototype.split()`方法使用
5. `Symbol.toPrimitive`：当一个对象转换为对应的原始值时（隐式转换等），会调用此函数。
6. `Symbol.toStringTag`：由`String.prototype.toString()`方法使用
