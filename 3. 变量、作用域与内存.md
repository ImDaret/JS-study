---
title: 变量、作用域与内存
---

## 变量

```javascript
let a = 1;
let b = "1";
let c = false;
let d = undefined;
let e = null;
let f = Symbol();
let g = {};
let h = [];
console.log(typeof a); // number
console.log(typeof b); // string
console.log(typeof c); // boolean
console.log(typeof d); // undefined
console.log(typeof e); // object
console.log(typeof f); // symbol
console.log(typeof g); // object
console.log(typeof h); // object
```

用 typeof 操作符原始类型除了`null`都会返回自己的类型，引用类型返回`object`，`null`返回 object，所以如果变量是引用类型，可以使用`instanceof`操作符来判断（通过原型链）,原型链的末端是 Object,所以用`instanceof`操作符检测引用值和 Object 都会返回 true， ECMA-262 规定，任何实现内部`[[Call]]`方法的对象都应该再 typeof 检测时返回`function`,所有再 Safari 和 Chrome 中检测正则表达式会返回`function`。

`var`关键字声明的变量会进行变量提升，通俗的说就是拿到函数或全局作用域的顶部，位于作用域中所有代码之前。

严格的说，`let`声明的变量也会进行变量提升，但是由于“暂时性死区”的存在，所以不能在声明之前使用 let 变量。

## 执行上下文

执行上下文分为全局上下文、函数上下文、块级上下文

代码执行流每进入一个新的上下文都会创建一个作用域链用于搜索变量和函数

子上下文可以访问父上下文的变量和函数，但是反过来不行

变量的执行上下文用于确定什么时候释放内存

## 垃圾回收

垃圾回收程序会周期性运行。

### 标记清理

在程序执行过程中，会给变量加上标记，当垃圾回收程序启动时，会将所有在上下文中的变量以及被在上下文中引用的变量的标记去掉，所以后面只要带有标记的就是待删除的，随后就做一次内存清理，销毁带标记的所有值并回收他们的内存。

### 引用计数

顾名思义，在程序执行过程中，生命一个变量并给它赋值，这个值的引用数就为 1，如果这个值又赋给了另一个值，这个值就为 2，如果该另一个值保存的值被覆盖了，那么引用数就减一，当引用数为 0 时就可以回收内存了。这是早期的垃圾回收策略，存在很大问题，比如循环引用，a 的某个属性引用了 b,b 的某个属性引用了 a，那么它们的引用树永远不可能为 0。早期的 BOM 和 DOM 对象都是 COM 对象模型（C++实现的组件对象模型），所以只要涉及这块的就用引用计数垃圾回收策略，但是当 COM 对象和 JavaScript 对象互相引用时，它们俩永远不会被回收，所以后来把 BOM 和 DOM 都改成了 JavaScript 对象，并统一使用标记清理来回收内存。、

### 性能

垃圾回收程序的启动频率很重要，启动频繁了会影响其他程序，启动慢了又会造成垃圾累积，所以一般这个过程是动态的，根据 V8 团队所说，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收

### 内存管理

#### 解除引用

```javascript
const createPerson = (name) => {
  let obj = new Object();
  obj.name = name;
  return obj;
};

const xiaoming = createPerson("xiaoming");

xiaoming = null;
```

上述代码中当 createPerson 执行完毕垃圾回收时会回收 obj 变量，但是 createPerson 本身并不会回收，因为 xiaoming 是一个全局变量，所以应该在没用时手动指定为 null 来接触引用，在下一次垃圾回收时回收这个函数，以达到性能提升。

#### 隐藏类和删除操作

```javascript
function Person() {
  this.name = "111";
}

let p1 = new Person();
let p2 = new PerSon();
```

这两个 p1p2 在执行时，V8 会在后台配置，让这两个类示例共享，因为使用了同一构造函数，但是当添加如下代码时，就分别对应两个隐藏类了

```javascript
p2.age = 20;
```

如果要改善就如下：

```javascript
function Person(age) {
  this.name = "111";
  this.age = age;
}

let p1 = new Person();
let p2 = new PerSon(20);
```

使用 delete 关键字也是同样道理

```javascript
delete p2.age;
```

当该代码执行时，p1 和 p2 不在共享实例类，如果要改善就置为`null`:

```javascript
p2.age = null;
```

#### 内存泄漏

1. 意外的全局变量,没有使用关键字声明。
2. 定时器引用了一个变量，只要定时器没结束，变量的内存就一直在
3. 闭包
